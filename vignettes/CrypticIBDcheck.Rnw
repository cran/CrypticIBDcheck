%\documentclass[article]{jss}
\documentclass[nojss]{jss} % if pdflatex'ing to make the vignette,
                             % remove the JSS header and footer
%\usepackage{natbib}
%\setcitestyle{aysep={,}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{url}
% \VignetteIndexEntry{CrypticIBDcheck package features, with application to data from a case-control candidate gene study}
% \VignettePackage{CrypticIBDcheck}

%% almost as usual
\author{Annick Nembot-Simo\\Simon Fraser University \And 
        Jinko Graham\\ Simon Fraser University \And
        Brad McNeney\\ Simon Fraser University}
\title{\pkg{CrypticIBDcheck} : An R package for checking cryptic 
relatedness in nominally unrelated individuals}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Annick Nembot-Simo, Jinko Graham, Brad McNeney} %% comma-separated
\Plaintitle{CrypticIBDcheck : An R package for  checking 
cryptic relatedness in nominally unrelated individuals} %% without formatting
\Shorttitle{CrypticIBDcheck} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
In population association studies, standard methods of statistical 
inference assume that study subjects are independent samples. 
In genetic association studies,
it is therefore of interest to diagnose undocumented close relationships 
in nominally unrelated study samples.
We describe the R package \pkg{CrypticIBDcheck} to identify pairs of 
closely-related subjects based on genetic marker data from
single-nucleotide polymorphisms (SNPs).
The package is able to accommodate SNPs
in linkage disequibrium (LD), without the need to
thin the markers so that they are approximately independent
in the population.  Sample pairs are identified
by superposing their estimated identity-by-descent (IBD) coefficients 
on plots of IBD coefficients for pairs of simulated subjects from one 
of several common close relationships. 
The methods are particularly relevant to
candidate-gene association studies, in
which dependent SNPs cluster in a relatively
small number of genes spread throughout the genome.
The accommodation of LD allows the use of all available genetic data,
a desirable property when working with a modest number of 
dependent SNPs within candidate genes.
\pkg{CrypticIBDcheck} is available from the Comprehensive R Archive
Network (CRAN).
%
}
\Keywords{cryptic relatedness, IBD estimation, linkage disequilibrium, gene drop simulation}
\Plainkeywords{cryptic relatedness, IBD estimation, linkage disequilibrium, gene drop simulation} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Brad McNeney\\
  Department of Statistics and Actuarial Science\\
  Simon Fraser University\\
  Burnaby, BC, Canada\\
  E-mail: \email{mcneney@sfu.ca}\\
  URL: \url{http://stat.stat.sfu.ca}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

%\section[About Java]{About \proglang{Java}}
%% Note: If there is markup in \(sub)section, then it has to be escape as above.

\section{Introduction}

It is well known that the results of genetic association studies 
may be confounded by the presence of undocumented relationships -- 
a phenomenon referred to as cryptic relatedness 
\citep[e.g.,][]{DevlinRoeder1999,VoightPritchard2005}. 
Before making any inference with the data, it is therefore important to 
understand cryptic relatedness in the study sample. To facilitate this 
understanding, we introduce \pkg{CrypticIBDcheck}, an R package for
exploring the presence of close relationships in a homogeneous sample
of nominally unrelated individuals.  Although several methods for
exploring cryptic relatedness have been implemented (reviewed below), 
%none are available as R packages, to our knowledge. \pkg{CrypticIBDcheck} 
none are geared for data from candidate-gene association studies.
\pkg{CrypticIBDcheck} fills this need. For ease of interpretation, the package 
implements exploratory displays based on popular measures of 
gene-identity by descent.  However, a unique feature of these displays 
is that they accommodate population linkage disequilibrium (LD) 
amongst genetic markers.  The accommodation of LD allows the use of data
on all available markers rather than on a subset whose alleles are 
approximately independent in the population.  This feature is attractive in 
candidate-gene association studies, where markers within genes are in LD 
but the number of genes is too small to select an independent subset 
of markers that is informative for relationship.  

\smallskip
%IBD COEFF DEF
The relatedness between two individuals may be defined in terms of the 
proportion of loci at which they share zero, one or two alleles that are 
identical-by-descent (IBD).  We refer to these proportions as the 
actual IBD-sharing coefficients, or IBD coefficients.  
The alleles from two individuals are IBD if they are descended 
from a common ancestor in a given reference population
\citep[e.g.,][]{Weiretal2006}. 
%\shortcites{Weiretal2006,Choietal2009,Abecasisetal2001,Purcelletal2007}.
Though alleles from each of two individuals may match or be
identical-by-state (IBS), they are not necessarly IBD. 

\smallskip
\pkg{CrypticIBDcheck} uses estimated IBD coefficients 
to summarize possible relationships among pairs of study subjects.
The approach is exploratory and graphically-based,
similar to the GRR approach of \citet{Abecasisetal2001}
and the approach of \citet{Gogarten12} implemented in the
\code{ibdPlot()} function of the \pkg{GWASTools} 
\proglang{Bioconductor} package. 

\smallskip
GRR calculates and displays 
the mean and variance of IBS allele sharing over polymorphic 
loci for each pair of individuals. 
Pairs of known relationships form reference clusters on the plot, 
allowing the user to identify errors in reported relationships. 
In association studies of nominally unrelated individuals, however,
there are no reference clusters available.  In principle,
reference clusters could be obtained theoretically
from the joint distribution of the IBS mean and variance estimators,
but it is unclear how to derive this distribution in the presence of LD. 

\smallskip
The \code{ibdPlot()} function in \pkg{GWASTools} may be applied 
to view estimated IBD coefficients
along with reference clusters for the unobserved, true
IBD coefficients based on theoretical moments
of their distribution \citep{HillWeir11}. 
However, in candidate-gene studies with a modest number of SNPs,
errors introduced by estimation of IBD coefficients cannot be ignored.
Hence, reference distributions for the true IBD coefficients
do not adequately represent those for estimated IBD coefficents.

\smallskip
The idea behind \pkg{CrypticIBDcheck} is to identify closely-related 
study pairs by displaying their estimated IBD coefficients
together with those from {\em simulated pairs} of known relationships. 
The simulated reference pairs provide an empirical joint distribution of the 
IBD estimators under selected relationships which, in turn,
suggest possible relationships amongst study pairs.
Working with simulated pairs from known relationships
avoids having to derive the joint distribution of the IBD 
estimators when the genetic markers are in LD. 
Simulated pairs are obtained by gene drop on a relationship-specific pedigree,
with pedigree-founder haplotypes drawn from a fitted haplotype model
that accounts for LD \citep{Thomas2010}. We have implemented simulation
of the following common relationships: monozygotic twins/sample duplicates,
parent-offspring, full siblings, second degree 
(i.e., half siblings, avuncular or grandparent-grandchild) and first cousins.  
However, users may also specify their own custom relationships
(see Section~\ref{sec:moreGD}).

\smallskip
The paper is structured as follows. In Section 2 we describe the IBD
estimators, and methods for gene drop simulation in the 
presence of LD to obtain reference clusters.
Section 3 discusses implementation details.
In Section 4, two examples showing how to use the package 
are provided. Finally, Section 5 includes a discussion
and ideas for future work. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{Methods}

\subsection{IBD estimation}

There are two common approaches to estimating IBD coefficients: maximum 
likelihood \citep{Thompson1975,Milligan2003,Choietal2009} and the method of 
moments \citep{Ritland1996,LynchRitland1999,Purcelletal2007}. 
Typically, maximum-likelihood estimators (MLEs)
are more biased than method-of-moments estimators (MMEs), 
especially when the number of loci is small; they are also
more computationally expensive \citep{LynchRitland1999}. 
However, MMEs are less precise than MLEs and can fall outside the 
biologically meaningful parameter space \citep{Milligan2003}. 

\bigskip
In this section, we review a popular method of moments approach to estimating
IBD coefficients introduced by \citet{Purcelletal2007} and implemented
in PLINK.  This approach assumes that the individuals are from the 
same homogeneous, random-mating and non-inbred population. 
Alleles from two individuals are considered to be IBD if they are 
descended from a common ancestor in some base population that we 
take to be relatively recent. All alleles in this base population 
are defined to be non-IBD. Given a SNP 
with alleles $A$ and $a$, a pair of individuals that are, say,
$AA$ and $aa$, respectively, will be denoted $(AA,aa)$. 

\bigskip
Identity-by-state (IBS) for a pair of subjects
is denoted by the random variable $I$ and identity-by-descent by 
the random variable $Z$, with
possible states being 0, 1, and 2 for both random variables. 
The IBD coefficients to be estimated are the proportions of 
genome shared IBD, denoted by
$P(Z=0)$, $P(Z=1)$, and $P(Z=2)$. For a given SNP $m$, the 
procedure begins by expressing the prior probability of IBS sharing 
as 
\begin{eqnarray}
P_m(I=i)= \sum_{z=0}^{i}P_m(I=i|Z=z)P(Z=z).
\label{e:IBS}
\end{eqnarray}
$P(Z=z)$ and $P_m(I=i)$ are specific to the pair of
subjects being considered, 
while the conditional SNP-specific IBS probabilities $P_m(I=i |Z=z)$ apply
to all pairs.
For a given pair of individuals at a given SNP, the above equation
specifies three identities for the IBS states 0, 1, and 2.
These three identities are summed over SNPs and then
rearranged to express $P(Z=0)$, $P(Z=1)$, and $P(Z=2)$ for the pair
in terms of  marginal and conditional IBS probabilities. 
For example, in the case of $i=z=0$, we obtain
$$P(Z=0)=\sum_m P_m(I=0)/\sum_m P_m(I=0|Z=0).$$ 
The method-of-moments estimators of IBD coefficients for a given pair
are obtained by substituting estimators of the conditional 
SNP-specific IBS probabilities, 
$P_m(I=i|Z=z)$,  pertaining to any pair
and the pair's marginal SNP-specific IBS probabilities, $P_m(I=i)$,
into the identities
and then solving for $P(Z=i)$. 

\bigskip
The marginal SNP-specific IBS probabilities, $P_m(I=i)$
for a pair of subjects may be estimated by the indicator
function for whether the pair has $I=i$ at the SNP.
An unbiased estimator  of $\sum_m \hat{P}_m(I=i)$
is therefore the count of SNPs at which the pair shares $i$ alleles IBS.
Estimates of the SNP-specific conditional IBS probabilities, $P_m(I=i|Z=z)$, 
are based on data from all subjects in the sample. 
Derivation of unbiased estimators of 
$P_m(I=i|Z=z)$ is more involved.
To simplify notation, we temporarily drop the SNP subscript $m$.
If $p$ and $q = 1-p$ denote the frequencies of $A$
and $a$ in the base population, then $P(I=i|Z=z)$ 
is a function of $p$ and $q$. 
For example, two individuals share 0 alleles IBS if
they are either $(AA,aa)$ or $(aa,AA)$. Given that $Z=0$, the probabilities
of these genotypes are $p^2q^2$ and 
$q^2p^2$, respectively, leading to  
$P(I=0|Z=0)=2p^2q^2$. The plug-in estimators of conditional
IBS probabilities, such as $P(I=0|Z=0)$,
obtained by inserting estimators $\hat{p}$ and $\hat{q}$ are biased
(Appendix A). Unbiased estimators, expressed as the 
plug-in estimator multiplied by a 
correction factor, may be derived as described next.

\bigskip
Let $X$ and $Y$ be the 
counts of the alleles $A$ and $a$, respectively, so that the allele frequency
estimators are  
$\hat{p}=X/T$ and $\hat{q}=Y/T$, where $T$ is twice the number of 
observed genotypes in the population random sample. 
The estimators of the conditional IBS probabilities 
$P(I=i|Z=z)$ may be motivated by the following model.
The genotype of each individual in the present population is 
obtained from two independent draws from 
an infinite base population of alleles.
Consequently, the $T$ alleles of a population random sample of study subjects
can be viewed as a random sample from the base population.
Moreover, conditional on IBD status, any pair of individuals 
in the present population can 
be viewed as independent allelic draws from the base population,
with the number of draws determined by their IBD status. 

\bigskip
For example, in the case of $Z=0$, a random pair of individuals 
results from randomly drawing two pairs of alleles from the base
population. An indicator variable of whether this sampling
process results in $I=0$ is an unbiased estimator of $P(I=0|Z=0)$. 
An unbiased estimator is therefore the average of these indicator
variables over all possible draws from the $T$ alleles on which we have data; 
i.e., the proportion of pairs of allelic pairs with $I=0$. 
The proportion can be computed as follows.
The number of ways of selecting four distinct alleles from a total of 
$T$ is $T(T-1)(T-2)(T-3)$. Without loss of generality, 
suppose the first two alleles are assigned to the first individual in 
a pair and the last two alleles to the second individual. 
Then the number of pairs that are $(AA,aa)$ and $(aa,AA)$ 
are $X(X-1)Y(Y-1)$ and $Y(Y-1)X(X-1)$, respectively. 
Hence,
\begin{eqnarray}
\hat{P}(I=0|Z=0)= \frac{2X(X-1)Y(Y-1)}{T(T-1)(T-2)(T-3)},
\label{e:phat}
\end{eqnarray} 
is an unbiased estimator of $P(I=0|Z=0)$ (see Appendix A for verification
by direct computation).
After algebra, the unbiased estimator may be expressed in terms of the allele 
frequency estimators and a correction factor as:
\begin{eqnarray*}
\hat{P}(I=0|Z=0)= 2\hat{p}^2\hat{q}^2\left(\frac{X-1}{X}\times\frac{Y-1}{Y}\times\frac{T}{T-1}\times\frac{T}{T-2}\times\frac{T}{T-3}\right).
\end{eqnarray*} 

\bigskip
For $Z=1$, we consider a pair of individuals to be
the result of drawing three alleles from the base population, 
one of which is shared by the pair of individuals.  
The proportion of such pairs of individuals
with IBS state $I=1$ in our data is an unbiased estimator of $P(I=1|Z=1)$.
The number of ways to select three distinct alleles from a total of $T$ 
is $T(T-1)(T-2)$. Among these, the genotype pairs that are 
$I=1$ are the $X(X-1)Y$, $YX(X-1)$, $Y(Y-1)X$, and 
$XY(Y-1)$ that are $(AA,Aa)$, $(Aa,AA)$, $(aa,Aa)$, and $(Aa,aa)$,
respectively. Thus,
\begin{eqnarray*}
\hat{P}(I=1|Z=1)&=&\frac{2X(X-1)Y+2XY(Y-1)}{T(T-1)(T-2)}\nonumber\\
&=& \frac{2XYX}{TT^2}\left(\frac{X-1}{X}\times\frac{T}{T-1}\times\frac{T}{T-2}\right) + \frac{2XY^2}{TT^2}\left(\frac{X-1}{X}\times\frac{T}{T-1}\times\frac{T}{T-2}\right)\nonumber\\
&=& 2\hat{p}^2\hat{q}\left(\frac{X-1}{X}\times\frac{T}{T-1}\times\frac{T}{T-2}\right) + 2\hat{p}\hat{q}^2\left(\frac{X-1}{X}\times\frac{T}{T-1}\times\frac{T}{T-2}\right).
\end{eqnarray*} 
The other conditional IBS probabilities are estimated in an analogous 
manner and their expressions are provided in 
Table 1 of \citet{Purcelletal2007}.

\bigskip
With estimates $\hat{P}_m(I=i)$ and $\hat{P}_m(I=i|Z=z)$ for each SNP, 
we sum over SNPs to obtain estimates of the IBD coefficients for a 
given pair in the sample. 
% The count of SNPs with IBS state $I=i$ 
% and IBD state $Z=z$ denoted $N(I=i|Z=z)$ and the count of SNPs 
% with IBS state $I=i$ denoted $N(I=i)$ are obtained by summing 
% $P(I=i|Z=z)$ and $P(I=i)$ respectively over all the SNPs. Thus,
Let
\begin{eqnarray}
\hat{N}(I=i|Z=z)&=&\sum_{m=1}^{L}\hat{P}_m(I=i|Z=z) \;\; \mbox{and} \nonumber\\
\hat{N}(I=i)&=&\sum_{m=1}^{L}\hat{P}_m(I=i),
\label{e:Nhat}
\end{eqnarray}  
where $L$ is the total number of SNPs with genotype data on both individuals.
For any pair of subjects, summing equation (\ref{e:IBS}) over all the SNPs and 
using equation (\ref{e:Nhat}) gives the following method-of-moment estimators
of the IBD coefficients:
\begin{eqnarray*}
\hat{P}(Z=0)&=& \frac{\hat{N}(I=0)}{\hat{N}(I=0|Z=0)}\\
\hat{P}(Z=1)&=& \frac{\hat{N}(I=1)-\hat{P}(Z=0)\times \hat{N}(I=1|Z=0)}{\hat{N}(I=1|Z=1)}\\
\hat{P}(Z=2)&=& \frac{\hat{N}(I=2)-\hat{P}(Z=0)\times \hat{N}(I=2|Z=0)-\hat{P}(Z=1)\times \hat{N}(I=2|Z=1)}{\hat{N}(I=2|Z=2)}.
\end{eqnarray*}  

\citet{Purcelletal2007} proposed adjustments to bound these 
estimators to values consistent with their 
interpretation as IBD proportions.  We have not made
these adjustments in our graphical displays.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Gene drop simulation with LD}

The package provides a graphical display that can be used to identify 
related sample pairs by plotting the estimated IBD coefficients $\hat{P}(Z=1)$
versus $\hat{P}(Z=0)$. To assess the variability of these estimators 
the points of the IBD plot are superposed on reference clusters obtained
from one of the following relationships: unrelated, 
monozygotic twins/duplicates,
parent-offspring, full siblings, half siblings and first cousins. 
These reference clusters are obtained by gene drop simulation 
that accounts for LD \citep{Thomas2009b}. A strength of this approach
is that we do not need to assume independence of marker loci.
In candidate-gene association studies, this feature is
important because of the dependence among a relatively small
number of SNPs.  Ignoring the dependence
among SNPs within genes produces reference clusters
that are too tight relative to the true variability,
and can lead to false-positive results. We return to this
point in the examples.

\bigskip
A graphical model is an approach to modeling the 
joint distribution of a set of dependent random variables when many 
independences or conditional independences exist between subsets of 
the variables. In the case of LD, it is expected that the joint 
distribution of alleles allong haplotypes shows such a structure.
\citet{Thomas2009a} 
describes a flexible graphical model of haplotype frequencies
that captures LD between loci.
The model is fit to data from subjects that
can be regarded as a population random sample; e.g., the controls in a 
case-control study of a rare disease. 
Model parameters are estimated by use of a stochastic
optimization algorithm \citep{Thomas2009b}. 

\bigskip
Once the LD model is fit, it is used to sample haplotypes
for the founders of a pedigree.  Data on the remaining 
members of the pedigree are simulated by gene drop. 
Gene drop is a method for randomly 
generating the genotypes of related individuals in a pedigree.
Alleles are ``dropped'' from the founders through the pedigree according
to Mendel's laws. Multi-locus gene drop incorporates the process of
recombination.
%, in which chromosomes exchange genetic material
% during gametogenesis.
To illustrate the simulation procedure, 
consider a parent-offspring relationship.
A pedigree that encompasses this relationship is one comprised
of two parents and the offspring. The founders are the parents.
Parental haplotypes are simulated from the fitted LD model and are 
then dropped to the offspring. To mimic real data with missing genotypes, 
selected genotypes for a simulated individual are set to missing
according to the missing genotype pattern of a randomly-sampled
study subject. 

\bigskip
Programs for fitting LD models and performing gene drop simulations
are available in the Java Programs for Statistical Genetics and 
Computational Statistics (JPSGSC) library 
developed by Alun Thomas 
(\url{http://balance.med.utah.edu/wiki/index.php/JPSGCS}). 
We use the R package \pkg{rJPSGCS} \citep{rJPSGCS}
to access these programs from R.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation}

The main function in \pkg{CrypticIBDcheck} is \code{IBDcheck()},
which estimates IBD coefficients for pairs of study subjects 
and optionally for simulated pairs of subjects and returns
an object of class \code{IBD}. The plot method for the 
\code{IBD} class displays the IBD coefficients 
for pairs of study subjects, along with prediction ellipses 
for known relationship pairs.

\bigskip
The arguments of \code{IBDcheck()} are constructed by the functions 
\code{new.IBD()}, \code{filter.control()} and \code{sim.control()}. 
The function \code{new.IBD} produces an object of class \code{IBD} 
suitable for input to \code{IBDcheck()}. At a minimum,
such an object includes the genetic data as a \code{snp.matrix}
object from the \pkg{chopsticks} package \citep{chopsticks},
a data frame of SNP information that includes chromosome and 
physical map positions of each SNP, and
a data frame of subject information that includes 
a logical vector indicating whether 
(\code{TRUE}) or not (\code{FALSE})
each subject is to be used to estimate
the conditional IBS probabilities and fit the LD model.
The documentation for \code{new.IBD()} and the examples 
below provide further details.
The function \code{filter.control()} sets
options for quality 
control filtering of data by SNPs and by subjects, while
the function \code{sim.control()} sets options that control 
simulation of subjects by gene drop.
The respective help files and the examples below provide
further details.
As the fitting of LD models in \code{IBDcheck()} 
can be computationally demanding, 
users have the option of splitting
computations across a \pkg{snow} cluster \citep{snow}, 
as described in Appendix B.
The output of \code{IBDcheck()} is an object of class \code{IBD}, which 
includes the estimated IBD coefficients for pairs of study subjects 
and for simulated pairs with known relationship. 

\bigskip
\code{IBD} objects are graphically displayed by the plot method of the 
class; the documentation for this method is available through
\code{help("plot.IBD")}.
Plots are of $\hat{P}(Z=1)$ versus
$\hat{P}(Z=0)$ for pairs of study subjects, with prediction ellipses
for known relationships superposed, if requested by the user.
The prediction ellipses are produced from estimated IBD coefficients 
for a user-specified number (default 200) of simulated pairs of 
known relationships, assuming the distribution of estimated 
IBD coefficients is approximately bivariate Normal. 
The default setting for \code{IBDcheck()} is to omit simulated
pairs from the object. When simulated pairs are omitted,
plotting produces a single interactive display of estimated IBD 
coefficients for pairs of study subjects, on which points
may be identified by clicking with the mouse.
On the other hand, when the \code{IBD} object includes simulated pairs,
the function returns a series of plots, which the user is
prompted to view and interact with successively.
The first plot to appear is non-clickable and shows the 
estimated IBD coefficients for all pairs of study subjects,
along with the prediction ellipse for unrelated, simulated pairs.
Subsequent plots are clickable and correspond to each relationship
requested in the call to \code{IBDcheck()}. These relationship-specific
plots are for identifying pairs of study subjects which could have the
relationship. The plotting regions are
restricted to the neighborhood of the prediction ellipse for
the simulated pairs of that relationship, which is also drawn. 
If, however, the plotting region overlaps with the 
prediction ellipse for simulated unrelated pairs, 
the ellipse for simulated unrelated pairs is drawn as well.
Points falling within the 
prediction ellipse for the relationship
and outside the prediction 
ellipse for unrelated pairs are automatically flagged. 
In addition, 
users may click on points of study pairs that appear to be related 
but are not automatically flagged. 
The plot method produces a data frame of information on pairs
that have been flagged on the different plots, 
either automatically or interactively by the user through
clicking the mouse.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Examples}
% Use the CodeChunk enviroment from the jss.cls style file:
%\begin{CodeChunk}
%\begin{CodeInput}
% your R commands go here 
%\end{CodeInput}
%\begin{CodeOutput}
% your output goes here
%\end{CodeOutput}
%\end{CodeChunk}

In this section we illustrate the features of the 
\code{CrypticIBDcheck} package using the genetic data \code{Nhlsim}
that comes with the package.
These data were simulated to mimic the characteristics 
of SNP genotypes in subjects of European ancestry
from a candidate-gene, case-control study of non-Hodgkin Lymphoma
\citep{Schuetz12}.  The data set is a list comprised of 
(i) a \code{snp.matrix} object called \code{snp.data} with 
genotypes for 108 controls and 100 cases;
(ii) a vector \code{chromosome} of chromosome numbers for each SNP; 
(iii) a vector \code{physmap} of physical map positions of
each SNP, from 
build 36 of the human genome; and 
(iv) a binary vector \code{csct} with value
one for cases and zero for population controls. 
The binary vector \code{csct} is used to select controls for
fitting LD models and estimating conditional IBS probabilities.
All of the information in \code{Nhlsim} is required to run \code{IBDcheck()}.

\medskip
We present two examples.
In the first (Section~\ref{sec:default}), 
we illustrate basic use of \code{IBDcheck()} to 
fit LD models and do gene drop simulations. 
Once the user requests simulations,
there are a number of parameters, such as the
types of relationships to simulate, that control
the simulations. Each
simulation parameter has a default value, as
described in the help file for \code{sim.control()}.
In the analysis presented in Section~\ref{sec:default} we use these
default settings.
In the second example (Section~\ref{sec:moreGD}), 
we illustrate re-use of fitted LD models
to perform additional gene drop simulations, this time 
for a user-specified relationship.
For examples of how to use \code{IBDcheck()} to explore
genome-wide data, we refer readers to the package vignette 
\code{IBDcheck-hapmap} that 
illustrates an analysis of genome-wide data from HapMap,
using thinning of markers to reduce the computational burden.


\subsection{Default analysis with LD model fitting and gene drops}
\label{sec:default}

We first load the package and the \code{Nhlsim} data set.
\begin{CodeChunk}
\begin{CodeInput}
R> library(CrypticIBDcheck)
\end{CodeInput}
\begin{CodeOutput}
Loading required package: rJPSGCS
Loading required package: rJava
Loading required package: chopsticks
Loading required package: survival
Loading required package: splines
Loading required package: car
Loading required package: MASS
Loading required package: nnet
Loading required package: ellipse

Attaching package: `ellipse'

The following object(s) are masked from `package:car':

    ellipse
\end{CodeOutput}
\begin{CodeInput}
R> data(Nhlsim)
\end{CodeInput}
\end{CodeChunk}

Next we create an object of class \code{IBD} that can be used as input to
the \code{IBDcheck()} function. The \code{Nhlsim}
data does not include genetic map positions for the SNPs, so these will
be inferred from the physical positions, assuming the physical positions
are from build 36 of the human genome. 
We use subjects with case-control status 0 (controls) for 
estimating conditional IBS probabilities and fitting LD models. 
\begin{CodeChunk}
\begin{CodeInput}
R> popsam<-Nhlsim$csct==0 
R> dat<-new.IBD(Nhlsim$snp.data,Nhlsim$chromosome,Nhlsim$physmap,popsam)
\end{CodeInput}
\begin{CodeOutput}
Note: Input does not include genetic map locations (Gen_loc). 
Inferring genetic map from physical position (Position), 
assuming build 36 of the human genome.

Note: Using population sample subjects (popsam==TRUE) to fill in pvalues from tests of HWE.

Note: Input does not include subject ids (subids). Using rownames of snp.data.
\end{CodeOutput}
\end{CodeChunk}

In this illustration, we leave all QC filtering options 
(set by \code{filter.control()}) at 
their default values.  We use \code{sim.control()} to modify the 
default value of \code{simulate=FALSE} to \code{simulate=TRUE}, 
so that reference clusters are simulated.
\begin{CodeChunk}
\begin{CodeInput}
R> ss<-sim.control(simulate=TRUE)
R> cibd<-IBDcheck(dat,simparams=ss)
\end{CodeInput}
\end{CodeChunk}
This call to \code{IBDcheck()} will generate 22 plain-text files in 
the user's
working directory that contain details of the fitted LD models for
each of the 22 autosomal chromosomes.
The names of these files are stored in the 
output \code{IBD} object:
\begin{CodeChunk}
\begin{CodeInput}
R> cibd$simparams$LDfiles
\end{CodeInput}
\begin{CodeOutput}
 [1] "GD1.ld.par"  "GD2.ld.par"  "GD3.ld.par"  "GD4.ld.par"  "GD5.ld.par" 
 [6] "GD6.ld.par"  "GD7.ld.par"  "GD8.ld.par"  "GD9.ld.par"  "GD10.ld.par"
[11] "GD11.ld.par" "GD12.ld.par" "GD13.ld.par" "GD14.ld.par" "GD15.ld.par"
[16] "GD16.ld.par" "GD17.ld.par" "GD18.ld.par" "GD19.ld.par" "GD20.ld.par"
[21] "GD21.ld.par" "GD22.ld.par"
\end{CodeOutput}
\end{CodeChunk}
Section \ref{sec:moreGD} gives an example of how to re-use these
fitted LD models for performing additional gene drops.
The output includes
estimated IBD coefficients for pairs of subjects in the input data 
and for simulated pairs of subjects from the following relationships: 
unrelated, duplicates/MZ twins, 
parent-offspring, full siblings and half-siblings. Simulation of 
first-cousin or user-specified relationship pairs is also possible, 
but is not done by default.
First cousins are typically not distinguishable from unrelated pairs
with data from a candidate-gene association study. 
The estimated IBD coefficients can be plotted with the plot method for
the \code{IBD} class.
\begin{CodeChunk}
\begin{CodeInput}
R> ibdpairs=plot(cibd)
R> ibdpairs
\end{CodeInput}
\begin{CodeOutput}
  member1 member2       pz0       pz1     relationship
1    sub1  sub201 0.0000000 1.0170209 parent-offspring
2    sub2  sub202 0.0000000 1.0049532 parent-offspring
3  sub203  sub206 0.1941393 0.5161277        full sibs
4  sub204  sub207 0.2294063 0.5217202        full sibs
5  sub205  sub208 0.2057583 0.4434503        full sibs
6   sub31   sub44 0.5264858 0.4505440        half sibs
\end{CodeOutput}
\end{CodeChunk}
In this example, the plotting function produces five plots, shown in 
Figures \ref{fig1}--\ref{fig3}, and an output data frame 
\code{ibdpairs} that contains information on study pairs flagged 
with the last four plots in Figures \ref{fig2} and \ref{fig3}. 

\bigskip
Figure \ref{fig1} shows the non-clickable 
plot  of the estimated IBD coefficients, $P(Z=1)$ versus $P(Z=0)$, for 
all pairs of study subjects, with the prediction ellipse for unrelated
pairs superposed.  The level of the prediction ellipse
is left at its default value of 
\code{ellipse.coverage=0.95} and, for unrelated pairs,
is adjusted to account for the majority of
study pairs being unrelated. Specifically, 
a Bonferroni-type adjustment, 
$1-(1-\mbox{\tt ellipse.coverage})/n_p$,
is applied, where $n_p$ 
is the number of pairs of study subjects. 
One purpose of the prediction ellipse is to avoid confusing the 
display by adding points for simulated pairs.
Another purpose is to avoid having to manually click points 
for study pairs that appear within a cloud of points
from simulated pairs.  We adopted a bivariate normal
approximation to the prediction ellipse because
it correctly identified the majority of points 
in experiments with simulated data (e.g. Figure ~\ref{fig1}). 
However, in Figure~\ref{fig1}, 
several unrelated pairs appear outside the 
prediction ellipse, indicating
that the distribution of estimated IBD coefficients
is slightly heavier-tailed than the bivariate normal approximation.

\bigskip
For the four other plots, shown in Figures~\ref{fig2} and \ref{fig3},
points that lie within a 95\% prediction ellipse 
(the default level for
\code{ellipse.coverage})
for the given relationship {\em and} outside the prediction ellipse for 
unrelated pairs are automatically flagged. In addition,
these plots are clickable, and points flagged manually are added
to the output dataframe. For example, on the plot for
half-siblings, the point corresponding to the pair \code{sub35} and
\code{sub95} has been manually flagged (Figure~\ref{fig3}, right panel);
this pair appears in both the prediction ellipse for
unrelated pairs and the upper portion of the prediction ellipse for
half siblings. Manually clicking on the point for this pair adds 
the following row to the output dataframe \code{ibdpairs}:
\begin{CodeChunk}
\begin{CodeOutput}
7   sub35   sub95 0.4568146 0.6351182        half sibs
\end{CodeOutput}
\end{CodeChunk}

\begin{figure}[!h]
\centering
\includegraphics[width=0.80\textwidth]{outfig1.pdf}
\caption{Estimated IBD coefficients for all pairs of study subjects, with 
the prediction ellipse for unrelated pairs superposed.}
\label{fig1}
\end{figure}
In this data set, there are no duplicate/MZ twins pairs
and no pairs flagged as such (Figure~\ref{fig2}, left panel).
The two parent-offspring pairs in the \code{Nhlsim} data fall in the 
prediction ellipse for parent-offspring pairs (Figure~\ref{fig2},
right panel). Similarly, all three full-sibling pairs in the 
\code{Nhlsim} data fall in the prediction ellipse for full siblings
(Figure~\ref{fig3}, left panel). 
The substantial overlap of the prediction ellipses for half siblings and 
unrelated pairs (Figure~\ref{fig3}, right panel) indicates 
insufficient data to distinguish these two relationships.
Though there are no half-sibling pairs
in \code{Nhlsim}, one pair of unrelated subjects, \code{sub31} and
\code{sub44}, has
atypical estimated IBD coefficients that fall 
within the prediction 
ellipse for half siblings but outside the prediction ellipse for
unrelated pairs. 

\bigskip
The unrelated pair flagged as a potential 
half-sibling pair is a false-positive result.
We observed (results not shown) that the number of false-positive
related pairs is greatly increased if we fail to take the LD between SNPs
into account. Specifically, if we repeat the simulation of 
unrelated and half-sibling pairs of subjects assuming 
independent SNPs (\code{fitLD=FALSE}), we obtain 16 
false-positive half sibling pairs.  
These observations highlight that
na\"{i}vely ignoring the dependence
among SNPs produces reference clusters
that are too tight relative to the true variability.
\begin{figure}[!h]
\centering
\includegraphics[width=0.45\textwidth]{outfig2.pdf}
\includegraphics[width=0.45\textwidth]{outfig3.pdf}
\caption{Observed pairs with prediction ellipses for MZ twins/duplicates 
(left panel) and parent-offspring pairs (right panel) superposed.}
\label{fig2}
\end{figure}
\begin{figure}[!h]
\centering
\includegraphics[width=0.45\textwidth]{outfig4.pdf}
\includegraphics[width=0.45\textwidth]{outfig5.pdf}
\caption{Observed pairs with prediction ellipses for full-siblings pairs
(left panel) and half-sibling pairs (right panel) superposed. The 
magenta ellipse for unrelated subjects appears on each panel.}
\label{fig3}
\end{figure}


\subsection{Additional gene drops using previously-fit LD models}
\label{sec:moreGD}

By far the most computationally-demanding step of \code{IBDcheck()}
is the fitting of LD models. The fitted LD models
are stored in plain-text files in the working directory and can be 
re-used for future gene drops using the argument \code{LDfiles}
of \code{sim.control()}, as we now illustrate.
We also demonstrate how users can 
create their own relationships to use as reference clusters on 
the IBD plot.

\bigskip
Setting of simulation parameters, such as the names of 
fitted LD model files and specification of the relationships to simulate,
is done with the \code{sim.control()} function. 
Recall that the
names of the LD files are stored in the \code{IBD} object created
by a call to \code{IBDcheck()}; for example:
\begin{CodeChunk}
\begin{CodeInput}
R> cibd$simparams$LDfiles
\end{CodeInput}
\begin{CodeOutput}
 [1] "GD1.ld.par"  "GD2.ld.par"  "GD3.ld.par"  "GD4.ld.par"  "GD5.ld.par" 
 [6] "GD6.ld.par"  "GD7.ld.par"  "GD8.ld.par"  "GD9.ld.par"  "GD10.ld.par"
[11] "GD11.ld.par" "GD12.ld.par" "GD13.ld.par" "GD14.ld.par" "GD15.ld.par"
[16] "GD16.ld.par" "GD17.ld.par" "GD18.ld.par" "GD19.ld.par" "GD20.ld.par"
[21] "GD21.ld.par" "GD22.ld.par"
\end{CodeOutput}
\end{CodeChunk}
These fitted models are re-used by specifying their names as the argument
\code{LDfiles} to \code{sim.contol}:
\begin{CodeChunk}
\begin{CodeInput}
R> ss<-sim.control(simulate=TRUE, LDfiles=cibd$simparams$LDfiles)
\end{CodeInput}
\end{CodeChunk}

The \code{sim.control()} function can also be used to specify the
relationships to simulate; e.g., one can obtain simulated
cousin pairs with
\begin{CodeChunk}
\begin{CodeInput}
R> ss<-sim.control(simulate=TRUE, rship="cousin", 
                   LDfiles=cibd$simparams$LDfiles)
\end{CodeInput}
\end{CodeChunk}
It is also possible to obtain pairs simulated according to
a user-specified relationship.
In the following, the relationship of interest is parent-offspring 
with first cousins parents. The relationship is 
depicted in Figure~\ref{fig:pedigree}, which was drawn using
Pedfiddler \citep{Pedfiddler}.
\begin{figure}[!h]
\centering
\includegraphics[height=3in,width=2.5in]{ped.pdf}
\caption{Pedigree for an offspring of a first-cousin marriage.
Circles represent females, squares represent males. Lines of 
descent are indicated by connections between nodes. The mother 
and daughter of interest are labelled as 2 and 1, respectively.  }
\label{fig:pedigree}
\end{figure}
To simulate according to this relationship, it is necessary to 
specify a minimal pedigree that captures the relationship between
the mother and daughter
{\em and} to have the mother and daughter be the first two
members of the pedigree. The pedigree drawn in Figure~\ref{fig:pedigree} 
has parents (nodes 2 and 3) that are first cousins.
Pedigree information is specified in a data frame whose rows
describe subjects. The columns of the data frame are member IDs,
the IDs of each member's father and mother,
and gender, coded as 1 for male and 2 for female.
For pedigree founders, the father and mother IDs are set to zero.
Specification of the pedigree in Figure~\ref{fig:pedigree} is as follows:
\begin{CodeChunk}
\begin{CodeInput}
userdat<-data.frame(ids=1:9,
                    dadids=c(3,5,7,0,9,9,0,0,0),
                    momids=c(2,4,6,0,8,8,0,0,0),
                    gender=c(2,2,1,2,1,2,1,2,1))
\end{CodeInput}
\end{CodeChunk}
The call to \code{IBDcheck()} would then be:
\begin{CodeChunk}
\begin{CodeInput}
ss<-sim.control(simulate=TRUE,
                rships="user", userdat=userdat, 
                LDfiles=cibd$simparams$LDfiles)
ff<-filter.control(filter=FALSE) # no need to re-filter data
cibd.user<-IBDcheck(cibd,simparams=ss,filterparams=ff)
\end{CodeInput}
\end{CodeChunk}
On the plot of \code{cibd.user} (not shown) the prediction ellipse for
simulated mother-daughter pairs where the daughter is inbred is
very similar to that from simulated pairs
where the daughter is not inbred (Figure~\ref{fig2}, right panel).
However, relative to the non-inbred case,
the prediction ellipse in the inbred case is shifted slightly
downward on the plot, 
reflecting the fact that the probability of 
2 genes IBD is now non-zero and the probability of 1 gene IBD is 
therefore smaller.

\section{Summary}

% Summary
\pkg{CrypticIBDcheck} is an R package for exploring cryptic
relatedness in a homogeneous sample of nominally unrelated individuals.
The main function of the package, \code{IBDcheck()}, computes
estimates of IBD coefficients for pairs of study subjects and, 
optionally, for pairs of subjects simulated to have one of 
several known relationships.  Simulated data for a given relationship 
are obtained by gene drop simulation on a pedigree that captures the 
relationship, with founder haplotypes simulated according to an LD model 
fit to the data. Objects of class \code{IBD} returned by 
\code{IBDcheck()} are displayed by the plot method of the class. Pairs 
of study subjects whose estimated IBD coefficients are consistent with 
one of the relationships requested in the call to \code{IBDcheck()} are 
flagged, either automatically or interactively by user mouse-clicks, and 
returned in a data frame.

\smallskip
% What is our contribution?
The methods implemented in \pkg{CrypticIBDcheck} are geared specifically 
towards exploring cryptic relatedness with data from candidate-gene 
association studies.  These studies involve a relatively modest number 
of SNPs which are correlated because they are clustered within 
candidate genes.  With a modest number of SNPs, the variability in 
the estimator of IBD coefficients cannot be ignored. Hence,
reference distributions for true IBD coefficients
do not adequately represent those for estimated IBD coefficients.
In addition, 
thinning to an approximately independent and yet informative set of 
SNPs is not an option.  Nor is ignoring LD and assuming SNPs are 
approximately independent.  As illustrated in the Examples, ignoring 
LD leads to reference clusters that are too tight.

\smallskip
% Notes on computation, flexibility and extensibility
Fitting LD models can be computationally-demanding for data sets
with more than a few thousand SNPs.  To minimize the time spent 
fitting LD models, \code{IBDcheck()} can distribute fitting of LD models
across a \pkg{snow} cluster, and LD files from one call to 
\code{IBDcheck()} can be re-used in future calls to add simulated pairs 
from a known relationship to an \code{IBD} object.
We offer the user complete flexibility with respect to the 
type of relationships and number of pairs of each relationship
to be simulated.  Users can choose from a number of close relationships
built-in to \code{IBDcheck()}, or specify their own relationships,
as illustrated in Section~\ref{sec:moreGD}.

% Future work? No.

\section*{Acknowledgements}
We thank John Spinelli for access to the non-Hodgkin lymphoma study data.
This work was supported by the Natural Sciences
and Engineering Research Council of Canada (NSERC) and 
by the Mathematics of Information Technology and Complex
Systems (Mitacs), Canadian Networks of Centres of Excellence.

%%%%%%%%%%%%%%%%%%%%
% Bibliography                                         %
%%%%%%%%%%%%%%%%%%%%
%dcu agsm
%\bibliographystyle{agsm}
\bibliography{CibdCbib}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\appendix 
\section*{Appendix A: Bias of conditional IBS estimators}
We calculate the bias of the plug-in and unbiased estimators
of $P(I=0|Z=0)$. Bias calculations for estimators of other conditional IBS 
probabilities are similar. Throughout, consider SNPs with 
alleles $A$ and $a$, and let $p$ be the population allele
frequency of $A$. Let $T$ be twice the number
of observed genotypes for the SNP 
in the population random sample.
Let $X$ be the number of $A$ alleles 
among the $T$ sampled and
$\hat{p}=X/T$.

\subsection*{Bias of the plug-in estimator}
We first prove the bias of the estimator
$2\hat{p}^2(1-\hat{p})^2$
of $P(I=0|Z=0)$.
Since $X \sim$ Binomial $(T,p)$.
\begin{eqnarray*}
E[\hat{P}(I=0|Z=0)]&=&2E[\hat{p}^2(1-\hat{p})^2]\\
&=&\frac{2}{T^4}E(X^2(T-X)^2)\\
&=&\frac{2}{T^4}[T^2E(X^2)-2TE(X^3)+E(X^4)].
\end{eqnarray*}
This calculation requires the second, third and fourth moments of the 
binomial distribution which can be obtained from the moment generating 
function:
\begin{eqnarray*}
E(X^2)&=&Tp+T(T-1)p^2\\
E(X^3)&=&Tp+3T(T-1)p^2+T(T-1)(T-2)p^3\\
E(X^4)&=&Tp+7T(T-1)p^2+6T(T-1)(T-2)p^3+T(T-1)(T-2)(T-3)p^4.
\end{eqnarray*}
Thus,
\begin{eqnarray*}
E( 2\hat{p}^2 \hat{q}^2 )
=\frac{2}{T^4}[Tp(T^2-2T+1)+p^2T(T-1)(T^2-6T+7)+\\ 
\qquad \qquad p^3T(T-1)(T-2)(-2T+6)+T(T-1)(T-2)(T-3)p^4],
\end{eqnarray*}
which is not equal to $2p^2q^2$.

\subsection*{Unbiased estimator}
We now show that the estimator of $P(I=0|Z=0)$. 
in equation (\ref{e:phat}) is 
unbiased.
Let $W=X(X-1)Y(Y-1)$ so that
$E[\hat{P}(I=0|Z=0)]=2E(W)/[T(T-1)(T-2)(T-3)]$.
Then
\begin{eqnarray*}
E(W)&=&E[(X^2-X)(Y^2-Y)]\\
&=&E[(X^2-X)((T-X)^2-T+X)]\\
&=&E[X^4-2TX^3+X^2(T^2+T-1)-X(T^2-T)]\\
&=&E(X^4)-2TE(X^3)+(T^2+T-1)E(X^2)-T(T-1)E(X)\\
&=&p(T-T^3+T^2-2T^2+T^3+T^2-T)+p^2[7T(T-1)\\
\qquad &-&6T^2(T-1)+T(T-1)(T^2+T-1)]\\
\qquad &+&p^3[6T(T-1)(T-2)-2T^2(T-1)(T-2)]+T(T-1)(T-2)(T-3)p^4\\
&=&p^2[T(T-1)(T^2-5T+6)+pT(T-1)(T-2)(6-2T)+p^2T(T-1)(T-2)(T-3)].
\end{eqnarray*}
Therefore,
\begin{eqnarray*}
E[\hat{P}(I=0|Z=0)]&=&\frac{2E(W)}{T(T-1)(T-2)(T-3)}\\
&=&2p^2\left[\frac{T^2-5T+6}{(T-2)(T-3)}+2p\frac{3-T}{T-3}+p^2\right] \\
&=&2p^2(1-2p+p^2)\\
&=&2p^2(1-p)^2\\
&=&2p^2q^2.
\end{eqnarray*}

\section*{Appendix B: Splitting computations over a snow cluster}

When the simulation parameters 
\code{simulate=TRUE} and \code{fitLD=TRUE}, 
the function \code{IBDcheck()} can be computationally demanding
for data sets with more than about 1000 SNPs. For example,
analysis of the \code{Nhlsim} data presented in section \ref{sec:default}
took about 40 minutes on an X86-based PC with a 
2.4GHz, dual-core, Intel processor.
Our package offers the option to use a \pkg{snow} cluster in order to split 
the fitting of LD models and gene drop simulations across 
different processors. In this appendix we distinguish between 
a \pkg{snow} cluster running in an interactive R session
on a single computer,
and a \pkg{snow} cluster running in batch mode on a compute cluster. 

\bigskip
As an example of interactive use on a computer with, say, eight processors,
one might create an eight-node socket cluster and use this 
cluster in a call to \code{IBDcheck()} as follows:
\begin{CodeChunk}
\begin{CodeInput}
R> library(snow)
R> cl<-makeCluster(8,type="SOCK")
R> clusterEvalQ(cl,library("CrypticIBDcheck"))
R> ss<-sim.control(simulate=TRUE,cl=cl)
R> cibd.cl<-IBDcheck(dat,simparams=ss)
R> stopCluster(cl)
\end{CodeInput}
\end{CodeChunk}

To produce
the set of plots displayed in Figures \ref{fig1}--\ref{fig3}:
\begin{CodeChunk}
\begin{CodeInput}
R> plot(cibd.cl)
\end{CodeInput}
\end{CodeChunk}


\bigskip
The steps required to run \code{IBDcheck()} in batch mode on a compute cluster
will depend on the setup of the compute cluster.
We describe the necessary steps for
a compute cluster at our institution as an example.
Our local cluster uses the Torque Portable Batch System 
(PBS; see the documentation at
\url{http://www.clusterresources.com/torquedocs21/usersmanual.shtml})
for running and submitting jobs and the Maui scheduler for scheduling 
the submitted jobs. Job submission is through a PBS file, submitted to the 
head node of the cluster, which in turn invokes an R script to carry 
out the computations. 
The following PBS file was used to fit the LD models and 
do gene drops with the
\code{Nhlsim} data.
\begin{verbatim}
--------------------------Nhlsim.pbs------------------------
## submit this job to the cluster head node with 
##    qsub -V Nhlsim.pbs
#!/bin/sh
#PBS -S /bin/bash
## Specify resources: 22 nodes, one processor per node, total of 16GB 
## memory, estimate total time to complete of 50 minutes
#PBS -l nodes=22:ppn=1,mem=16gb,walltime=00:50:00
## Capture messages to stdout and stderr in files.
#PBS -o Nhlsimrun.out
#PBS -e Nhlsimrun.err
## Execute any shell commands needed to give the job access to R. 
## On our cluster: 
##     source /hpc/software/etc/colony-login
##     module load LANG/R/2.14.0
## Change to the directory from which the job was submitted
cd $PBS_O_WORKDIR
## Run the R script
R --vanilla -f Nhlsim.R
-----------------------------------------------------------
\end{verbatim}

The PBS script calls the following R script to carry out the 
analysis. The script assumes the R packages \pkg{snow} and 
\pkg{Rmpi} have been installed on the cluster.
\begin{verbatim}
--------------------------Nhlsim.R--------------------------
library(snow)
cl<-makeCluster(22,type="MPI")
clusterEvalQ(cl,library("CrypticIBDcheck"))
ss<-sim.control(simulate=TRUE,cl=cl)
cibd.cl<-IBDcheck(dat,simparams=ss)
save(cibd.cl,file="cibd.cl.RData")
stopCluster(cl)
-----------------------------------------------------------
\end{verbatim}

After the \code{Nhlsim.pbs} job has finished, one can start an 
interactive R session in
the directory that contains the file \code{cibd.cl.RData}
and plot the results as follows:
\begin{CodeChunk}
\begin{CodeInput}
R> library(CrypticIBDcheck)
R> load("cibd.cl.RData")
R> plot(cibd.cl)
\end{CodeInput}
\end{CodeChunk}
These commands produce
the set of plots displayed in Figures \ref{fig1}--\ref{fig3}.

\end{document}
